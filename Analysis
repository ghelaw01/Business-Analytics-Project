3. Data Analysis

In this section, we detail the data analysis process, including data preprocessing, exploratory data analysis (EDA), customer segmentation, and demand forecasting.

3.1 Data Preprocessing

The dataset comprises transactional records from a UK-based online retailer, spanning from December 2010 to December 2011. The key variables include:

InvoiceNo: Unique identifier for each transaction.

StockCode: Unique identifier for each product.

Description: Product description.

Quantity: Number of units sold per transaction.

InvoiceDate: Date and time of the transaction.

UnitPrice: Price per unit of the product.

CustomerID: Unique identifier for each customer.

Country: Country of the customer.

Data preprocessing steps included:

Handling Missing Values: Transactions with missing CustomerID or `

Data preprocessing is a crucial step in preparing the dataset for meaningful analysis. The following steps were taken:

Handling Missing Values

Transactions with missing CustomerID were removed.
Any records with negative Quantity values (representing returns) were excluded.
Feature Engineering

Created a Total Price variable:
TotalPrice
=
Quantity
×
UnitPrice
TotalPrice=Quantity×UnitPrice
Extracted date-based features such as day, month, and year from InvoiceDate.
Filtering Data

Focused only on United Kingdom transactions to avoid country-specific variations in customer behavior.
Data Preprocessing
# Load necessary libraries
library(dplyr)
library(lubridate)

# Load the dataset
df <- read.csv("Online_Retail_Cleaned.csv", stringsAsFactors = FALSE)

# Remove missing values
df <- df %>% filter(!is.na(CustomerID))

# Remove returns (negative quantities)
df <- df %>% filter(Quantity > 0)

# Create Total Price column
df$TotalPrice <- df$Quantity * df$UnitPrice

# Convert InvoiceDate to Date type
df$InvoiceDate <- as.Date(df$InvoiceDate, format="%m/%d/%Y %H:%M")

# Extract year, month, day
df$Year <- year(df$InvoiceDate)
df$Month <- month(df$InvoiceDate)
df$Day <- day(df$InvoiceDate)

# Filter data for UK customers only
df <- df %>% filter(Country == "United Kingdom")

# Display the first few rows
head(df)
3.2 Exploratory Data Analysis (EDA)
EDA helps in understanding the distribution of the data and uncovering trends in customer purchases.

Key Questions Explored in EDA
What are the top-selling products?
How do sales trends change over time?
What is the distribution of customer spending?
Visualization 1: Monthly Sales Trends
library(ggplot2)

# Aggregate sales by month
monthly_sales <- df %>%
  group_by(Year, Month) %>%
  summarise(TotalSales = sum(TotalPrice))

# Plot
ggplot(monthly_sales, aes(x = factor(Month), y = TotalSales, fill = factor(Year))) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(title = "Monthly Sales Trends", x = "Month", y = "Total Sales") +
  theme_minimal()
Visualization 2: Top 10 Best-Selling Products
# Aggregate sales by product
top_products <- df %>%
  group_by(Description) %>%
  summarise(TotalSales = sum(TotalPrice)) %>%
  arrange(desc(TotalSales)) %>%
  head(10)

# Plot
ggplot(top_products, aes(x = reorder(Description, TotalSales), y = TotalSales)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(title = "Top 10 Best-Selling Products", x = "Product", y = "Total Sales") +
  theme_minimal()
Visualization 3: Customer Spending Distribution
# Aggregate spending by customer
customer_spending <- df %>%
  group_by(CustomerID) %>%
  summarise(TotalSpending = sum(TotalPrice))

# Plot histogram
ggplot(customer_spending, aes(x = TotalSpending)) +
  geom_histogram(bins = 50, fill = "blue", alpha = 0.7) +
  labs(title = "Customer Spending Distribution", x = "Total Spending", y = "Number of Customers") +
  theme_minimal()
4. Customer Segmentation Using K-Means Clustering
4.1 Segmentation Approach
We use K-Means clustering to group customers based on their Recency, Frequency, and Monetary (RFM) values.
RFM Definition:
Recency: Days since last purchase.
Frequency: Number of transactions.
Monetary: Total amount spent.
R Code for Customer Segmentation
library(cluster)

# Calculate RFM values
rfm_data <- df %>%
  group_by(CustomerID) %>%
  summarise(Recency = as.numeric(Sys.Date() - max(InvoiceDate)),
            Frequency = n_distinct(InvoiceNo),
            Monetary = sum(TotalPrice))

# Normalize data
rfm_scaled <- scale(rfm_data[,-1])

# Determine optimal number of clusters
wss <- sapply(1:10, function(k) kmeans(rfm_scaled, centers=k, nstart=10)$tot.withinss)
plot(1:10, wss, type="b", pch=19, col="red", main="Elbow Method for Optimal K")

# Apply K-Means with 4 clusters
set.seed(42)
kmeans_model <- kmeans(rfm_scaled, centers=4, nstart=10)

# Add cluster labels to the dataset
rfm_data$Cluster <- factor(kmeans_model$cluster)

# Visualize Clusters
ggplot(rfm_data, aes(x = Frequency, y = Monetary, color = Cluster)) +
  geom_point(alpha = 0.7) +
  labs(title = "Customer Segmentation Based on RFM", x = "Frequency", y = "Monetary Value") +
  theme_minimal()
5. Predictive Stock Replenishment Using Time Series Forecasting
5.1 Approach
We use Prophet for time series forecasting to predict product demand based on historical sales.
R Code for Time Series Forecasting
library(prophet)

# Aggregate daily sales
daily_sales <- df %>%
  group_by(InvoiceDate) %>%
  summarise(TotalSales = sum(TotalPrice))

# Rename columns for Prophet
colnames(daily_sales) <- c("ds", "y")

# Fit the Prophet model
m <- prophet(daily_sales)

# Create future dataframe for predictions
future <- make_future_dataframe(m, periods = 90)

# Predict future sales
forecast <- predict(m, future)

# Plot forecast
plot(m, forecast) +
  labs(title = "Sales Forecast for Next 3 Months")
6. Discussion, Results, and Insights
Customer segmentation results show four distinct groups:
High-value, frequent buyers (Require priority stock availability)
Moderate-value customers (May be targeted with promotions)
Seasonal buyers (Stocking strategies should align with seasonal demand)
Low-frequency buyers (Potential for re-engagement campaigns)
Sales forecasting suggests peak demand periods, allowing for better inventory planning.
Stock replenishment strategies can be adjusted dynamically for each segment, reducing overstocking and minimizing lost sales.
